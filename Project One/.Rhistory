frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM2_ts)
get.best.arima <- function(x.ts, maxord=c(2,2,2,2,2,2))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM2_ts)
get.best.arima <- function(x.ts, maxord=c(2,2,2,2,2,2))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,2,2,2,2,2))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM4_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM4_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- Arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='ML')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='ML')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), lambda=BoxCox.lambda(x.ts), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM1_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM4_ts)
get.best.arima <- function(x.ts, maxord=c(2,1,1,2,1,1))
{
# confirm input is a ts object
if(!is.ts(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): x.ts should be a ts time series object')
# remove the leading and trailing NA observations
x.ts <- na.trim(x.ts)
# confirm we have sufficent data for a time series analysis
if(length(x.ts) < 5 * frequency(x.ts))
stop('In get.best.arima(x.ts, maxord=c(p,d,q,P,D,Q)): time series x.ts not sufficiently long')
# function from Introductory Time Series with R
best.aic <- 1e8 # a big number
n <- length(x.ts)
for(p in 0:maxord[1]) for(d in 0:maxord[2]) for(q in 0:maxord[3])
{
for(P in 0:maxord[4]) for(D in 0:maxord[5]) for(Q in 0:maxord[6])
{
fit <- arima(x.ts, order=c(p,q,d), seasonal=list(order=c(P,D,Q),
frequency(x.ts)), method='CSS')
fit.aic <- -2 * fit$loglik + (log(n) + 1) * length(fit$coef)
if(fit.aic < best.aic)
{
best.aic <- fit.aic
best.fit <- fit
best.model <- c(p,d,q,P,D,Q)
}
}
}
return(list(best.fit,best.model,best.aic))
}
get.best.arima(ATM2_ts)
# General
library('easypackages')
libraries('knitr', 'kableExtra', 'default')
# Processing
libraries('readxl', 'tidyverse', 'janitor', 'lubridate')
# Graphing
libraries('ggplot2', 'grid', 'gridExtra')
# Timeseries
libraries('zoo', 'urca', 'tseries', 'timetk')
# Math
libraries('forecast')
### UNIVERSAL DATA SOURCING & DEFAULT SETTINGS FOR PROJECT
# Load All Sourced Code
suppressWarnings(source("scripts/Part-A-JM.R"))
# Set default augments for code chunks
knitr::opts_chunk$set(echo = F, message=F, warning=F, error=F, comment=F, fig.width=10, fig.height = 3)
# Set default augments for `kable_styling()`
default(kable) <- list(format="latex")
default(kable_styling)  <- list(latex_options = c("HOLD_position", "striped"))
default(row_spec) <- list(row=0, bold=T)
# Set default for ggplot theme
default(theme) <- list(axis.text.x = element_text(angle = 0, hjust = NULL),
plot.title = element_text(color="#4c4c4c", size=12, face="bold"),
plot.subtitle = (element_text(size=8, color="#000000")),
legend.title = (element_text(size=10, color="#000000", face="bold")),
strip.background = element_rect(color="#000000",
fill="#cccdd0", size=.75, linetype="solid"),
strip.text.x = element_text(size = 8, color = "#000000", face="bold"))
# GGplot Palette
default(scale_color_brewer) <- list(palette = 'RdPu', direction=1)
# plot atms as scatterplot
atm %>%
# re-gather observations for facet plot
gather(key=ATM, value=Cash, ATM1,ATM2, ATM3,ATM4) %>%
# remove NA value from ATM2
filter(complete.cases(.)) %>%
# plot
ggplot(aes(DATE, Cash, color=ATM)) +
geom_point() +
geom_smooth(method="loess") +
facet_wrap(~ATM, scales='free_x', nrow=1) +
labs(title="ATM Scatterplot",x="", y="Cash (in hundreds)")+
theme_bw()+
theme(legend.position = 'none', axis.text.x = element_text(angle = 45, hjust = 1)) +
scale_color_brewer()
autoplot(atm_zoo)+
labs(title = "Daily ATM Transactions", subtitle = "Series: ATM1", y="Cash (in hundreds)", x="")+
theme_bw()+ theme()
p1<-ggAcf(ATM1_ts)+ labs(title="ACF: ATM1")+ theme_bw()+theme()
p2<-ggPacf(ATM1_ts)+ labs(title="PACF: ATM1")+ theme_bw()+ theme()
p3<-ggAcf(ATM2_ts)+ labs(title="ACF: ATM2")+ theme_bw()+theme()
p4<-ggPacf(ATM2_ts)+ labs(title="PACF: ATM2")+ theme_bw()+ theme()
p5<-ggAcf(ATM4_ts)+ labs(title="ACF: ATM4")+ theme_bw()+theme()
p6<-ggPacf(ATM4_ts)+ labs(title="PACF: ATM4")+ theme_bw()+ theme()
grid.arrange(grob=p1, p3, p5, p2, p4, p6, ncol=3)
urATM1<-cbind("ATM"="ATM1", "No-Diff"=round(ATM1_ur@teststat,4),"Diff-1" =round(ATM1d_ur@teststat,4))
urATM2<-cbind("ATM"="ATM2", "No-Diff"=round(ATM2_ur@teststat,4),"Diff-1" =round(ATM2d_ur@teststat,4))
urATM4<-cbind("ATM"="ATM4", "No-Diff"=round(ATM4_ur@teststat,4),"Diff-1" =round(ATM4d_ur@teststat,4))
rbind(urATM1, urATM2,urATM4) %>% kable(caption="KPSS unit root test") %>% kable_styling() %>% row_spec()
p1<-ggAcf(ATM1_arima$residuals, lag=21)+ labs(title="ATM1", x="Lag", y="") +theme_bw()+theme()
p2<- gghistogram(ATM1_arima$residuals, add.normal = T)+
labs(title="ATM1", subtitle="ARIMA(0,1,0)(0,1,1)[7]",x="")+
theme_bw()+theme()
p3<-ggAcf(ATM2_arima$residuals, lag=21)+ labs(title="ATM2",x="Lag", y="") +theme_bw()+theme()
p4<-gghistogram(ATM2_arima$residuals, add.normal = T)+
labs(title="ATM2", subtitle="ARIMA(0,0,0)(0,1,1)[7]",x="")+
theme_bw()+theme()
p5<-ggAcf(ATM4_arima$residuals, lag=21)+ labs(title="ATM3",x="Lag", y="") +theme_bw()+theme()
p6<-gghistogram(ATM4_arima$residuals, add.normal = T)+
labs(title="ATM4", subtitle="ARIMA(0,1,0)(0,1,1)[7]", x="")+
theme_bw()+theme()
grid.arrange(grob=p1, p3, p5, ncol=3, top=textGrob(label="ACF Plots"))
grid.arrange(p2, p4, p6, ncol=3, top=textGrob(label="Residuals Plots"))
p1<-autoplot(ATM1_arima$fitted)+autolayer(ATM1_fc)+
coord_cartesian(xlim = c(45, 54))+
labs(subtitle = "ATM1 Series", x="Weeks", y="Cash")+theme_bw()+theme()
p2<-autoplot(ATM2_arima$fitted)+autolayer(ATM2_fc)+
coord_cartesian(xlim = c(45, 54))+
labs(subtitle = "ATM2 Series", x="Weeks", y="Cash")+theme_bw()+theme()
p3<-autoplot(ATM4_arima$fitted)+autolayer(ATM4_fc)+
coord_cartesian(xlim = c(45, 54))+
labs(subtitle = "ATM4 Series", x="Weeks", y="Cash")+theme_bw()+theme()
grid.arrange(p1, p2, p3, ncol=3, top=textGrob(label="ATM Forecasts"))
ATM1_fc %>% kable(caption="ATM1 Forecast") %>% kable_styling() %>% row_spec()
ATM2_fc %>% kable(caption="ATM2 Forecast") %>% kable_styling() %>% row_spec()
ATM4_fc %>% kable(caption="ATM4 Forecast") %>% kable_styling() %>% row_spec()
p1<-autoplot(ATM1_arima$fitted)+autolayer(ATM1_fc)+
coord_cartesian(xlim = c(48, 54))+
labs(subtitle = "ATM1 Series", x="Weeks", y="Cash")+theme_bw()+theme()
p2<-autoplot(ATM2_arima$fitted)+autolayer(ATM2_fc)+
coord_cartesian(xlim = c(48, 54))+
labs(subtitle = "ATM2 Series", x="Weeks", y="Cash")+theme_bw()+theme()
p3<-autoplot(ATM4_arima$fitted)+autolayer(ATM4_fc)+
coord_cartesian(xlim = c(48, 54))+
labs(subtitle = "ATM4 Series", x="Weeks", y="Cash")+theme_bw()+theme()
grid.arrange(p1, p2, p3, ncol=3, top=textGrob(label="ATM Forecasts"))
